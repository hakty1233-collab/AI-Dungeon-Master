{"ast":null,"code":"// frontend/src/utils/narrativeParser.js\n\n/**\n * Parse narrative text to detect dialogue and assign appropriate voices\n */\n\n// Voice descriptors mapped to ElevenLabs voice IDs\nconst VOICE_MAP = {\n  // Character traits\n  'gravelly': 'gruff',\n  'gruff': 'gruff',\n  'rough': 'gruff',\n  'deep': 'gruff',\n  'raspy': 'gruff',\n  'harsh': 'gruff',\n  'old': 'old_wise',\n  'ancient': 'old_wise',\n  'wise': 'old_wise',\n  'elderly': 'old_wise',\n  'aged': 'old_wise',\n  'young': 'young',\n  'youthful': 'young',\n  'child': 'young',\n  'cheerful': 'young',\n  'dark': 'dark',\n  'sinister': 'dark',\n  'menacing': 'dark',\n  'ominous': 'dark',\n  'evil': 'dark',\n  'female': 'female',\n  'woman': 'female',\n  'lady': 'female',\n  'male': 'male',\n  'man': 'male',\n  'epic': 'epic',\n  'booming': 'epic',\n  'powerful': 'epic',\n  'commanding': 'epic'\n};\n\n/**\n * Detect voice characteristics from descriptive text\n */\nfunction detectVoiceFromDescription(text) {\n  const lowerText = text.toLowerCase();\n  for (const [keyword, voice] of Object.entries(VOICE_MAP)) {\n    if (lowerText.includes(keyword)) {\n      return voice;\n    }\n  }\n  return 'narrator';\n}\n\n/**\n * Parse narrative text into segments with appropriate voices\n * Returns array of { text, voice, type }\n */\nexport function parseNarrative(text) {\n  const segments = [];\n\n  // Regex patterns for dialogue detection\n  const dialoguePatterns = [\n  // \"Character says, 'dialogue'\"\n  /([^.!?]*?)(?:says?|speaks?|asks?|replies?|whispers?|shouts?|yells?|murmurs?|growls?|hisses?)[,:]?\\s*['\"'\"](.*?)['\"'\"]/gi,\n  // \"Character's voice is X as they say, 'dialogue'\"\n  /([^.!?]*?voice[^.!?]*?)[,:]?\\s*['\"'\"](.*?)['\"'\"]/gi,\n  // Direct quotes without attribution\n  /['\"'\"](.*?)['\"'\"]/g];\n  let lastIndex = 0;\n  const matches = [];\n\n  // Find all dialogue matches\n  for (const pattern of dialoguePatterns) {\n    let match;\n    const patternCopy = new RegExp(pattern.source, pattern.flags);\n    while ((match = patternCopy.exec(text)) !== null) {\n      // Avoid duplicate matches\n      const isDuplicate = matches.some(m => Math.abs(m.index - match.index) < 10);\n      if (!isDuplicate) {\n        matches.push({\n          index: match.index,\n          fullMatch: match[0],\n          description: match[1] || '',\n          dialogue: match[2] || match[1] || match[0]\n        });\n      }\n    }\n  }\n\n  // Sort matches by position\n  matches.sort((a, b) => a.index - b.index);\n\n  // Build segments\n  matches.forEach((match, i) => {\n    // Add narration before this dialogue\n    if (match.index > lastIndex) {\n      const narrationText = text.slice(lastIndex, match.index).trim();\n      if (narrationText) {\n        segments.push({\n          text: narrationText,\n          voice: 'narrator',\n          type: 'narration'\n        });\n      }\n    }\n\n    // Add the dialogue with appropriate voice\n    const voice = detectVoiceFromDescription(match.description);\n    const dialogueText = match.dialogue.replace(/['\"'\"]/g, '').trim();\n    if (dialogueText) {\n      segments.push({\n        text: dialogueText,\n        voice: voice,\n        type: 'dialogue',\n        character: match.description.trim()\n      });\n    }\n    lastIndex = match.index + match.fullMatch.length;\n  });\n\n  // Add any remaining narration\n  if (lastIndex < text.length) {\n    const remainingText = text.slice(lastIndex).trim();\n    if (remainingText) {\n      segments.push({\n        text: remainingText,\n        voice: 'narrator',\n        type: 'narration'\n      });\n    }\n  }\n\n  // If no dialogue was detected, return entire text as narration\n  if (segments.length === 0) {\n    segments.push({\n      text: text,\n      voice: 'narrator',\n      type: 'narration'\n    });\n  }\n  return segments;\n}\n\n/**\n * Example usage and test\n */\nexport function testParser() {\n  const examples = [\"The figure's voice remains low and gravelly as it speaks, 'I am called Malakai, and I have been waiting for you, adventurer.'\", \"The old wizard says, 'You must find the crystal before nightfall.'\", \"'Help me!' the young girl cries out.\", \"The narrator describes a dark forest. 'This place is cursed,' whispers the ranger.\"];\n  console.log(\"=== Narrative Parser Tests ===\");\n  examples.forEach((example, i) => {\n    console.log(`\\nExample ${i + 1}:`, example);\n    console.log(\"Parsed segments:\", parseNarrative(example));\n  });\n}","map":{"version":3,"names":["VOICE_MAP","detectVoiceFromDescription","text","lowerText","toLowerCase","keyword","voice","Object","entries","includes","parseNarrative","segments","dialoguePatterns","lastIndex","matches","pattern","match","patternCopy","RegExp","source","flags","exec","isDuplicate","some","m","Math","abs","index","push","fullMatch","description","dialogue","sort","a","b","forEach","i","narrationText","slice","trim","type","dialogueText","replace","character","length","remainingText","testParser","examples","console","log","example"],"sources":["C:/Users/Hakty/Desktop/AI-Dungeon-Master/frontend/src/utils/narrativeParser.js"],"sourcesContent":["// frontend/src/utils/narrativeParser.js\n\n/**\n * Parse narrative text to detect dialogue and assign appropriate voices\n */\n\n// Voice descriptors mapped to ElevenLabs voice IDs\nconst VOICE_MAP = {\n  // Character traits\n  'gravelly': 'gruff',\n  'gruff': 'gruff',\n  'rough': 'gruff',\n  'deep': 'gruff',\n  'raspy': 'gruff',\n  'harsh': 'gruff',\n  \n  'old': 'old_wise',\n  'ancient': 'old_wise',\n  'wise': 'old_wise',\n  'elderly': 'old_wise',\n  'aged': 'old_wise',\n  \n  'young': 'young',\n  'youthful': 'young',\n  'child': 'young',\n  'cheerful': 'young',\n  \n  'dark': 'dark',\n  'sinister': 'dark',\n  'menacing': 'dark',\n  'ominous': 'dark',\n  'evil': 'dark',\n  \n  'female': 'female',\n  'woman': 'female',\n  'lady': 'female',\n  \n  'male': 'male',\n  'man': 'male',\n  \n  'epic': 'epic',\n  'booming': 'epic',\n  'powerful': 'epic',\n  'commanding': 'epic',\n};\n\n/**\n * Detect voice characteristics from descriptive text\n */\nfunction detectVoiceFromDescription(text) {\n  const lowerText = text.toLowerCase();\n  \n  for (const [keyword, voice] of Object.entries(VOICE_MAP)) {\n    if (lowerText.includes(keyword)) {\n      return voice;\n    }\n  }\n  \n  return 'narrator';\n}\n\n/**\n * Parse narrative text into segments with appropriate voices\n * Returns array of { text, voice, type }\n */\nexport function parseNarrative(text) {\n  const segments = [];\n  \n  // Regex patterns for dialogue detection\n  const dialoguePatterns = [\n    // \"Character says, 'dialogue'\"\n    /([^.!?]*?)(?:says?|speaks?|asks?|replies?|whispers?|shouts?|yells?|murmurs?|growls?|hisses?)[,:]?\\s*['\"'\"](.*?)['\"'\"]/gi,\n    \n    // \"Character's voice is X as they say, 'dialogue'\"\n    /([^.!?]*?voice[^.!?]*?)[,:]?\\s*['\"'\"](.*?)['\"'\"]/gi,\n    \n    // Direct quotes without attribution\n    /['\"'\"](.*?)['\"'\"]/g,\n  ];\n  \n  let lastIndex = 0;\n  const matches = [];\n  \n  // Find all dialogue matches\n  for (const pattern of dialoguePatterns) {\n    let match;\n    const patternCopy = new RegExp(pattern.source, pattern.flags);\n    \n    while ((match = patternCopy.exec(text)) !== null) {\n      // Avoid duplicate matches\n      const isDuplicate = matches.some(m => \n        Math.abs(m.index - match.index) < 10\n      );\n      \n      if (!isDuplicate) {\n        matches.push({\n          index: match.index,\n          fullMatch: match[0],\n          description: match[1] || '',\n          dialogue: match[2] || match[1] || match[0],\n        });\n      }\n    }\n  }\n  \n  // Sort matches by position\n  matches.sort((a, b) => a.index - b.index);\n  \n  // Build segments\n  matches.forEach((match, i) => {\n    // Add narration before this dialogue\n    if (match.index > lastIndex) {\n      const narrationText = text.slice(lastIndex, match.index).trim();\n      if (narrationText) {\n        segments.push({\n          text: narrationText,\n          voice: 'narrator',\n          type: 'narration',\n        });\n      }\n    }\n    \n    // Add the dialogue with appropriate voice\n    const voice = detectVoiceFromDescription(match.description);\n    const dialogueText = match.dialogue.replace(/['\"'\"]/g, '').trim();\n    \n    if (dialogueText) {\n      segments.push({\n        text: dialogueText,\n        voice: voice,\n        type: 'dialogue',\n        character: match.description.trim(),\n      });\n    }\n    \n    lastIndex = match.index + match.fullMatch.length;\n  });\n  \n  // Add any remaining narration\n  if (lastIndex < text.length) {\n    const remainingText = text.slice(lastIndex).trim();\n    if (remainingText) {\n      segments.push({\n        text: remainingText,\n        voice: 'narrator',\n        type: 'narration',\n      });\n    }\n  }\n  \n  // If no dialogue was detected, return entire text as narration\n  if (segments.length === 0) {\n    segments.push({\n      text: text,\n      voice: 'narrator',\n      type: 'narration',\n    });\n  }\n  \n  return segments;\n}\n\n/**\n * Example usage and test\n */\nexport function testParser() {\n  const examples = [\n    \"The figure's voice remains low and gravelly as it speaks, 'I am called Malakai, and I have been waiting for you, adventurer.'\",\n    \"The old wizard says, 'You must find the crystal before nightfall.'\",\n    \"'Help me!' the young girl cries out.\",\n    \"The narrator describes a dark forest. 'This place is cursed,' whispers the ranger.\",\n  ];\n  \n  console.log(\"=== Narrative Parser Tests ===\");\n  examples.forEach((example, i) => {\n    console.log(`\\nExample ${i + 1}:`, example);\n    console.log(\"Parsed segments:\", parseNarrative(example));\n  });\n}"],"mappings":"AAAA;;AAEA;AACA;AACA;;AAEA;AACA,MAAMA,SAAS,GAAG;EAChB;EACA,UAAU,EAAE,OAAO;EACnB,OAAO,EAAE,OAAO;EAChB,OAAO,EAAE,OAAO;EAChB,MAAM,EAAE,OAAO;EACf,OAAO,EAAE,OAAO;EAChB,OAAO,EAAE,OAAO;EAEhB,KAAK,EAAE,UAAU;EACjB,SAAS,EAAE,UAAU;EACrB,MAAM,EAAE,UAAU;EAClB,SAAS,EAAE,UAAU;EACrB,MAAM,EAAE,UAAU;EAElB,OAAO,EAAE,OAAO;EAChB,UAAU,EAAE,OAAO;EACnB,OAAO,EAAE,OAAO;EAChB,UAAU,EAAE,OAAO;EAEnB,MAAM,EAAE,MAAM;EACd,UAAU,EAAE,MAAM;EAClB,UAAU,EAAE,MAAM;EAClB,SAAS,EAAE,MAAM;EACjB,MAAM,EAAE,MAAM;EAEd,QAAQ,EAAE,QAAQ;EAClB,OAAO,EAAE,QAAQ;EACjB,MAAM,EAAE,QAAQ;EAEhB,MAAM,EAAE,MAAM;EACd,KAAK,EAAE,MAAM;EAEb,MAAM,EAAE,MAAM;EACd,SAAS,EAAE,MAAM;EACjB,UAAU,EAAE,MAAM;EAClB,YAAY,EAAE;AAChB,CAAC;;AAED;AACA;AACA;AACA,SAASC,0BAA0BA,CAACC,IAAI,EAAE;EACxC,MAAMC,SAAS,GAAGD,IAAI,CAACE,WAAW,CAAC,CAAC;EAEpC,KAAK,MAAM,CAACC,OAAO,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACR,SAAS,CAAC,EAAE;IACxD,IAAIG,SAAS,CAACM,QAAQ,CAACJ,OAAO,CAAC,EAAE;MAC/B,OAAOC,KAAK;IACd;EACF;EAEA,OAAO,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASI,cAAcA,CAACR,IAAI,EAAE;EACnC,MAAMS,QAAQ,GAAG,EAAE;;EAEnB;EACA,MAAMC,gBAAgB,GAAG;EACvB;EACA,yHAAyH;EAEzH;EACA,oDAAoD;EAEpD;EACA,oBAAoB,CACrB;EAED,IAAIC,SAAS,GAAG,CAAC;EACjB,MAAMC,OAAO,GAAG,EAAE;;EAElB;EACA,KAAK,MAAMC,OAAO,IAAIH,gBAAgB,EAAE;IACtC,IAAII,KAAK;IACT,MAAMC,WAAW,GAAG,IAAIC,MAAM,CAACH,OAAO,CAACI,MAAM,EAAEJ,OAAO,CAACK,KAAK,CAAC;IAE7D,OAAO,CAACJ,KAAK,GAAGC,WAAW,CAACI,IAAI,CAACnB,IAAI,CAAC,MAAM,IAAI,EAAE;MAChD;MACA,MAAMoB,WAAW,GAAGR,OAAO,CAACS,IAAI,CAACC,CAAC,IAChCC,IAAI,CAACC,GAAG,CAACF,CAAC,CAACG,KAAK,GAAGX,KAAK,CAACW,KAAK,CAAC,GAAG,EACpC,CAAC;MAED,IAAI,CAACL,WAAW,EAAE;QAChBR,OAAO,CAACc,IAAI,CAAC;UACXD,KAAK,EAAEX,KAAK,CAACW,KAAK;UAClBE,SAAS,EAAEb,KAAK,CAAC,CAAC,CAAC;UACnBc,WAAW,EAAEd,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE;UAC3Be,QAAQ,EAAEf,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC,CAAC,IAAIA,KAAK,CAAC,CAAC;QAC3C,CAAC,CAAC;MACJ;IACF;EACF;;EAEA;EACAF,OAAO,CAACkB,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACN,KAAK,GAAGO,CAAC,CAACP,KAAK,CAAC;;EAEzC;EACAb,OAAO,CAACqB,OAAO,CAAC,CAACnB,KAAK,EAAEoB,CAAC,KAAK;IAC5B;IACA,IAAIpB,KAAK,CAACW,KAAK,GAAGd,SAAS,EAAE;MAC3B,MAAMwB,aAAa,GAAGnC,IAAI,CAACoC,KAAK,CAACzB,SAAS,EAAEG,KAAK,CAACW,KAAK,CAAC,CAACY,IAAI,CAAC,CAAC;MAC/D,IAAIF,aAAa,EAAE;QACjB1B,QAAQ,CAACiB,IAAI,CAAC;UACZ1B,IAAI,EAAEmC,aAAa;UACnB/B,KAAK,EAAE,UAAU;UACjBkC,IAAI,EAAE;QACR,CAAC,CAAC;MACJ;IACF;;IAEA;IACA,MAAMlC,KAAK,GAAGL,0BAA0B,CAACe,KAAK,CAACc,WAAW,CAAC;IAC3D,MAAMW,YAAY,GAAGzB,KAAK,CAACe,QAAQ,CAACW,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAACH,IAAI,CAAC,CAAC;IAEjE,IAAIE,YAAY,EAAE;MAChB9B,QAAQ,CAACiB,IAAI,CAAC;QACZ1B,IAAI,EAAEuC,YAAY;QAClBnC,KAAK,EAAEA,KAAK;QACZkC,IAAI,EAAE,UAAU;QAChBG,SAAS,EAAE3B,KAAK,CAACc,WAAW,CAACS,IAAI,CAAC;MACpC,CAAC,CAAC;IACJ;IAEA1B,SAAS,GAAGG,KAAK,CAACW,KAAK,GAAGX,KAAK,CAACa,SAAS,CAACe,MAAM;EAClD,CAAC,CAAC;;EAEF;EACA,IAAI/B,SAAS,GAAGX,IAAI,CAAC0C,MAAM,EAAE;IAC3B,MAAMC,aAAa,GAAG3C,IAAI,CAACoC,KAAK,CAACzB,SAAS,CAAC,CAAC0B,IAAI,CAAC,CAAC;IAClD,IAAIM,aAAa,EAAE;MACjBlC,QAAQ,CAACiB,IAAI,CAAC;QACZ1B,IAAI,EAAE2C,aAAa;QACnBvC,KAAK,EAAE,UAAU;QACjBkC,IAAI,EAAE;MACR,CAAC,CAAC;IACJ;EACF;;EAEA;EACA,IAAI7B,QAAQ,CAACiC,MAAM,KAAK,CAAC,EAAE;IACzBjC,QAAQ,CAACiB,IAAI,CAAC;MACZ1B,IAAI,EAAEA,IAAI;MACVI,KAAK,EAAE,UAAU;MACjBkC,IAAI,EAAE;IACR,CAAC,CAAC;EACJ;EAEA,OAAO7B,QAAQ;AACjB;;AAEA;AACA;AACA;AACA,OAAO,SAASmC,UAAUA,CAAA,EAAG;EAC3B,MAAMC,QAAQ,GAAG,CACf,+HAA+H,EAC/H,oEAAoE,EACpE,sCAAsC,EACtC,oFAAoF,CACrF;EAEDC,OAAO,CAACC,GAAG,CAAC,gCAAgC,CAAC;EAC7CF,QAAQ,CAACZ,OAAO,CAAC,CAACe,OAAO,EAAEd,CAAC,KAAK;IAC/BY,OAAO,CAACC,GAAG,CAAC,aAAab,CAAC,GAAG,CAAC,GAAG,EAAEc,OAAO,CAAC;IAC3CF,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEvC,cAAc,CAACwC,OAAO,CAAC,CAAC;EAC1D,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}