{"ast":null,"code":"// ======================================================================\n// ADD THESE FUNCTIONS TO: frontend/src/utils/spellSystem.js\n// Location: At the end of the file, before the closing exports\n// ======================================================================\n\n/**\n * Get offensive spells that can be cast in combat\n */\nexport function getOffensiveSpells(character) {\n  var _character$spells;\n  const accessibleSpells = getAccessibleSpells(character);\n  const cantrips = ((_character$spells = character.spells) === null || _character$spells === void 0 ? void 0 : _character$spells.cantrips) || [];\n\n  // Combine cantrips and accessible spells\n  const allSpells = [...cantrips, ...accessibleSpells];\n\n  // Filter for spells that deal damage\n  return allSpells.map(key => ({\n    key,\n    ...SPELL_DATABASE[key]\n  })).filter(spell => spell && spell.damage); // Only offensive spells\n}\n\n/**\n * Make spell attack roll (for spells like Fire Bolt, Eldritch Blast)\n */\nexport function makeSpellAttackRoll(character, targetAC) {\n  const spellAttackBonus = getSpellAttackBonus(character);\n  const d20 = Math.floor(Math.random() * 20) + 1;\n  const total = d20 + spellAttackBonus;\n  const isCritical = d20 === 20;\n  const isFumble = d20 === 1;\n  const isHit = isCritical || !isFumble && total >= targetAC;\n  return {\n    d20,\n    total,\n    bonus: spellAttackBonus,\n    isHit,\n    isCritical,\n    isFumble,\n    targetAC\n  };\n}\n\n/**\n * Calculate and roll damage for a spell\n */\nexport function calculateAndRollSpellDamage(spell, character, upcastLevel = null, isCritical = false) {\n  const damageString = calculateSpellDamage(spell, character.level, upcastLevel);\n  if (!damageString) return null;\n  const result = rollSpellDamage(damageString);\n\n  // Critical hit doubles the dice (not modifiers)\n  if (isCritical && spell.damage) {\n    const extraRolls = rollSpellDamage(damageString);\n    const modifierValue = parseInt(extraRolls.modifier.replace('+', '')) || 0;\n    result.total += extraRolls.total - modifierValue;\n    result.rolls = [...result.rolls, ...extraRolls.rolls];\n    result.isCritical = true;\n  }\n  return result;\n}\n\n/**\n * Make saving throw for spell\n */\nexport function makeSpellSavingThrow(target, character, saveAbility = 'DEX') {\n  var _target$abilities;\n  const spellSaveDC = getSpellSaveDC(character);\n\n  // Get target's save modifier\n  const abilityScore = ((_target$abilities = target.abilities) === null || _target$abilities === void 0 ? void 0 : _target$abilities[saveAbility]) || 10;\n  const saveModifier = Math.floor((abilityScore - 10) / 2);\n  const d20 = Math.floor(Math.random() * 20) + 1;\n  const total = d20 + saveModifier;\n  const success = total >= spellSaveDC;\n  return {\n    d20,\n    total,\n    modifier: saveModifier,\n    dc: spellSaveDC,\n    ability: saveAbility,\n    success,\n    targetName: target.name\n  };\n}\n\n/**\n * Cast offensive spell in combat\n */\nexport function castOffensiveSpell(character, spell, target, upcastLevel = null) {\n  var _spell$castingTime, _spell$description, _spell$description2, _spell$description3;\n  const level = upcastLevel || spell.level;\n\n  // Check if can cast\n  if (spell.level > 0 && !canCastSpell(character, spell)) {\n    return {\n      success: false,\n      message: `No spell slots remaining for level ${spell.level}!`,\n      character\n    };\n  }\n\n  // Determine spell type\n  const isSpellAttack = ((_spell$castingTime = spell.castingTime) === null || _spell$castingTime === void 0 ? void 0 : _spell$castingTime.includes('action')) && spell.range !== 'Self' && spell.damage;\n  const isSaveSpell = ((_spell$description = spell.description) === null || _spell$description === void 0 ? void 0 : _spell$description.toLowerCase().includes('save')) || ((_spell$description2 = spell.description) === null || _spell$description2 === void 0 ? void 0 : _spell$description2.toLowerCase().includes('dex save')) || ((_spell$description3 = spell.description) === null || _spell$description3 === void 0 ? void 0 : _spell$description3.toLowerCase().includes('con save'));\n  let attackResult = null;\n  let saveResult = null;\n  let damageResult = null;\n  let finalDamage = 0;\n\n  // Spell attack (Fire Bolt, Scorching Ray, etc.)\n  if (isSpellAttack && !isSaveSpell) {\n    attackResult = makeSpellAttackRoll(character, target.ac || target.armorClass);\n    if (attackResult.isHit) {\n      damageResult = calculateAndRollSpellDamage(spell, character, level, attackResult.isCritical);\n      finalDamage = damageResult.total;\n    }\n  }\n  // Saving throw spell (Fireball, Lightning Bolt, etc.)\n  else if (isSaveSpell) {\n    var _spell$description4, _spell$description5, _spell$description6;\n    // Determine save ability from spell description\n    let saveAbility = 'DEX';\n    if ((_spell$description4 = spell.description) !== null && _spell$description4 !== void 0 && _spell$description4.toLowerCase().includes('con save')) saveAbility = 'CON';\n    if ((_spell$description5 = spell.description) !== null && _spell$description5 !== void 0 && _spell$description5.toLowerCase().includes('wis save')) saveAbility = 'WIS';\n    if ((_spell$description6 = spell.description) !== null && _spell$description6 !== void 0 && _spell$description6.toLowerCase().includes('str save')) saveAbility = 'STR';\n    saveResult = makeSpellSavingThrow(target, character, saveAbility);\n    damageResult = calculateAndRollSpellDamage(spell, character, level, false);\n\n    // Half damage on successful save\n    finalDamage = saveResult.success ? Math.floor(damageResult.total / 2) : damageResult.total;\n  }\n  // Auto-hit spell (Magic Missile)\n  else {\n    damageResult = calculateAndRollSpellDamage(spell, character, level, false);\n    finalDamage = damageResult.total;\n  }\n\n  // Consume spell slot\n  let updatedCharacter = character;\n  if (spell.level > 0) {\n    const castResult = castSpell(character, spell, level);\n    updatedCharacter = castResult.character;\n  }\n  return {\n    success: true,\n    character: updatedCharacter,\n    spell,\n    target: target.name,\n    attackResult,\n    saveResult,\n    damageResult,\n    finalDamage,\n    damageType: spell.damageType,\n    slotUsed: spell.level > 0 ? level : 0,\n    message: `Cast ${spell.name}!`\n  };\n}","map":{"version":3,"names":["getOffensiveSpells","character","_character$spells","accessibleSpells","getAccessibleSpells","cantrips","spells","allSpells","map","key","SPELL_DATABASE","filter","spell","damage","makeSpellAttackRoll","targetAC","spellAttackBonus","getSpellAttackBonus","d20","Math","floor","random","total","isCritical","isFumble","isHit","bonus","calculateAndRollSpellDamage","upcastLevel","damageString","calculateSpellDamage","level","result","rollSpellDamage","extraRolls","modifierValue","parseInt","modifier","replace","rolls","makeSpellSavingThrow","target","saveAbility","_target$abilities","spellSaveDC","getSpellSaveDC","abilityScore","abilities","saveModifier","success","dc","ability","targetName","name","castOffensiveSpell","_spell$castingTime","_spell$description","_spell$description2","_spell$description3","canCastSpell","message","isSpellAttack","castingTime","includes","range","isSaveSpell","description","toLowerCase","attackResult","saveResult","damageResult","finalDamage","ac","armorClass","_spell$description4","_spell$description5","_spell$description6","updatedCharacter","castResult","castSpell","damageType","slotUsed"],"sources":["C:/Users/Hakty/Desktop/AI-Dungeon-Master/frontend/src/utils/spellSystem.js"],"sourcesContent":["// ======================================================================\n// ADD THESE FUNCTIONS TO: frontend/src/utils/spellSystem.js\n// Location: At the end of the file, before the closing exports\n// ======================================================================\n\n/**\n * Get offensive spells that can be cast in combat\n */\nexport function getOffensiveSpells(character) {\n  const accessibleSpells = getAccessibleSpells(character);\n  const cantrips = character.spells?.cantrips || [];\n  \n  // Combine cantrips and accessible spells\n  const allSpells = [...cantrips, ...accessibleSpells];\n  \n  // Filter for spells that deal damage\n  return allSpells\n    .map(key => ({ key, ...SPELL_DATABASE[key] }))\n    .filter(spell => spell && spell.damage); // Only offensive spells\n}\n\n/**\n * Make spell attack roll (for spells like Fire Bolt, Eldritch Blast)\n */\nexport function makeSpellAttackRoll(character, targetAC) {\n  const spellAttackBonus = getSpellAttackBonus(character);\n  const d20 = Math.floor(Math.random() * 20) + 1;\n  const total = d20 + spellAttackBonus;\n  \n  const isCritical = d20 === 20;\n  const isFumble = d20 === 1;\n  const isHit = isCritical || (!isFumble && total >= targetAC);\n  \n  return {\n    d20,\n    total,\n    bonus: spellAttackBonus,\n    isHit,\n    isCritical,\n    isFumble,\n    targetAC\n  };\n}\n\n/**\n * Calculate and roll damage for a spell\n */\nexport function calculateAndRollSpellDamage(spell, character, upcastLevel = null, isCritical = false) {\n  const damageString = calculateSpellDamage(spell, character.level, upcastLevel);\n  if (!damageString) return null;\n  \n  const result = rollSpellDamage(damageString);\n  \n  // Critical hit doubles the dice (not modifiers)\n  if (isCritical && spell.damage) {\n    const extraRolls = rollSpellDamage(damageString);\n    const modifierValue = parseInt(extraRolls.modifier.replace('+', '')) || 0;\n    result.total += extraRolls.total - modifierValue;\n    result.rolls = [...result.rolls, ...extraRolls.rolls];\n    result.isCritical = true;\n  }\n  \n  return result;\n}\n\n/**\n * Make saving throw for spell\n */\nexport function makeSpellSavingThrow(target, character, saveAbility = 'DEX') {\n  const spellSaveDC = getSpellSaveDC(character);\n  \n  // Get target's save modifier\n  const abilityScore = target.abilities?.[saveAbility] || 10;\n  const saveModifier = Math.floor((abilityScore - 10) / 2);\n  \n  const d20 = Math.floor(Math.random() * 20) + 1;\n  const total = d20 + saveModifier;\n  const success = total >= spellSaveDC;\n  \n  return {\n    d20,\n    total,\n    modifier: saveModifier,\n    dc: spellSaveDC,\n    ability: saveAbility,\n    success,\n    targetName: target.name\n  };\n}\n\n/**\n * Cast offensive spell in combat\n */\nexport function castOffensiveSpell(character, spell, target, upcastLevel = null) {\n  const level = upcastLevel || spell.level;\n  \n  // Check if can cast\n  if (spell.level > 0 && !canCastSpell(character, spell)) {\n    return {\n      success: false,\n      message: `No spell slots remaining for level ${spell.level}!`,\n      character\n    };\n  }\n  \n  // Determine spell type\n  const isSpellAttack = spell.castingTime?.includes('action') && spell.range !== 'Self' && spell.damage;\n  const isSaveSpell = spell.description?.toLowerCase().includes('save') || \n                      spell.description?.toLowerCase().includes('dex save') ||\n                      spell.description?.toLowerCase().includes('con save');\n  \n  let attackResult = null;\n  let saveResult = null;\n  let damageResult = null;\n  let finalDamage = 0;\n  \n  // Spell attack (Fire Bolt, Scorching Ray, etc.)\n  if (isSpellAttack && !isSaveSpell) {\n    attackResult = makeSpellAttackRoll(character, target.ac || target.armorClass);\n    \n    if (attackResult.isHit) {\n      damageResult = calculateAndRollSpellDamage(spell, character, level, attackResult.isCritical);\n      finalDamage = damageResult.total;\n    }\n  }\n  // Saving throw spell (Fireball, Lightning Bolt, etc.)\n  else if (isSaveSpell) {\n    // Determine save ability from spell description\n    let saveAbility = 'DEX';\n    if (spell.description?.toLowerCase().includes('con save')) saveAbility = 'CON';\n    if (spell.description?.toLowerCase().includes('wis save')) saveAbility = 'WIS';\n    if (spell.description?.toLowerCase().includes('str save')) saveAbility = 'STR';\n    \n    saveResult = makeSpellSavingThrow(target, character, saveAbility);\n    damageResult = calculateAndRollSpellDamage(spell, character, level, false);\n    \n    // Half damage on successful save\n    finalDamage = saveResult.success ? Math.floor(damageResult.total / 2) : damageResult.total;\n  }\n  // Auto-hit spell (Magic Missile)\n  else {\n    damageResult = calculateAndRollSpellDamage(spell, character, level, false);\n    finalDamage = damageResult.total;\n  }\n  \n  // Consume spell slot\n  let updatedCharacter = character;\n  if (spell.level > 0) {\n    const castResult = castSpell(character, spell, level);\n    updatedCharacter = castResult.character;\n  }\n  \n  return {\n    success: true,\n    character: updatedCharacter,\n    spell,\n    target: target.name,\n    attackResult,\n    saveResult,\n    damageResult,\n    finalDamage,\n    damageType: spell.damageType,\n    slotUsed: spell.level > 0 ? level : 0,\n    message: `Cast ${spell.name}!`\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}