{"ast":null,"code":"// frontend/src/utils/spellCombatSystem.js\n\n/**\n * Spell Combat System\n * Handles spell casting, damage, saving throws, and spell attacks in combat\n */\n\nimport { SPELL_DATABASE } from './spellSystem';\nimport { applyDamage } from './combatSystem';\nimport { createStatusEffect, applyStatusEffect, STATUS_EFFECTS, DURATION_TYPES } from './statusEffectSystem';\n\n/**\n * Roll dice for spell damage\n */\nexport function rollSpellDamage(damageFormula) {\n  if (!damageFormula) return 0;\n\n  // Handle formulas like \"3d6\", \"4d8+4\", \"8d6\"\n  const match = damageFormula.match(/(\\d+)d(\\d+)([+-]\\d+)?/);\n  if (!match) {\n    // Flat damage like \"10\"\n    return parseInt(damageFormula) || 0;\n  }\n  const [, numDice, dieSize, modifier] = match;\n  let total = 0;\n  const rolls = [];\n  for (let i = 0; i < parseInt(numDice); i++) {\n    const roll = Math.floor(Math.random() * parseInt(dieSize)) + 1;\n    rolls.push(roll);\n    total += roll;\n  }\n  if (modifier) {\n    total += parseInt(modifier);\n  }\n  return {\n    total,\n    rolls,\n    formula: damageFormula,\n    modifier: modifier || '+0'\n  };\n}\n\n/**\n * Make a spell attack roll\n */\nexport function makeSpellAttack(caster, targetAC, spellAttackBonus = null) {\n  const d20 = Math.floor(Math.random() * 20) + 1;\n\n  // Calculate spell attack bonus if not provided\n  let attackBonus = spellAttackBonus;\n  if (attackBonus === null) {\n    const spellcastingAbility = getSpellcastingAbility(caster.class);\n    const abilityModifier = Math.floor((caster.abilities[spellcastingAbility] - 10) / 2);\n    const proficiencyBonus = Math.floor((caster.level - 1) / 4) + 2;\n    attackBonus = abilityModifier + proficiencyBonus;\n  }\n  const totalRoll = d20 + attackBonus;\n  const isCritical = d20 === 20;\n  const isFumble = d20 === 1;\n  const isHit = isCritical || !isFumble && totalRoll >= targetAC;\n  return {\n    d20,\n    attackBonus,\n    totalRoll,\n    isHit,\n    isCritical,\n    isFumble,\n    targetAC\n  };\n}\n\n/**\n * Make a saving throw for spell\n */\nexport function makeSpellSave(target, saveDC, saveAbility) {\n  var _target$abilities, _target$proficiencies, _target$proficiencies2;\n  const d20 = Math.floor(Math.random() * 20) + 1;\n\n  // Get ability modifier\n  const abilityScore = ((_target$abilities = target.abilities) === null || _target$abilities === void 0 ? void 0 : _target$abilities[saveAbility]) || 10;\n  const abilityModifier = Math.floor((abilityScore - 10) / 2);\n\n  // Check proficiency\n  const isProficient = ((_target$proficiencies = target.proficiencies) === null || _target$proficiencies === void 0 ? void 0 : (_target$proficiencies2 = _target$proficiencies.savingThrows) === null || _target$proficiencies2 === void 0 ? void 0 : _target$proficiencies2.includes(saveAbility)) || false;\n  const proficiencyBonus = target.level ? Math.floor((target.level - 1) / 4) + 2 : 0;\n  const saveModifier = abilityModifier + (isProficient ? proficiencyBonus : 0);\n  const totalRoll = d20 + saveModifier;\n  const success = d20 === 20 || totalRoll >= saveDC;\n  const criticalFail = d20 === 1;\n  return {\n    d20,\n    saveModifier,\n    totalRoll,\n    saveDC,\n    saveAbility,\n    success,\n    criticalFail\n  };\n}\n\n/**\n * Calculate spell save DC\n */\nexport function calculateSpellSaveDC(caster) {\n  const spellcastingAbility = getSpellcastingAbility(caster.class);\n  const abilityModifier = Math.floor((caster.abilities[spellcastingAbility] - 10) / 2);\n  const proficiencyBonus = Math.floor((caster.level - 1) / 4) + 2;\n  return 8 + proficiencyBonus + abilityModifier;\n}\n\n/**\n * Get spellcasting ability for class\n */\nexport function getSpellcastingAbility(className) {\n  const spellcastingAbilities = {\n    'Wizard': 'INT',\n    'Sorcerer': 'CHA',\n    'Warlock': 'CHA',\n    'Bard': 'CHA',\n    'Cleric': 'WIS',\n    'Druid': 'WIS',\n    'Paladin': 'CHA',\n    'Ranger': 'WIS',\n    'Monk': 'WIS',\n    // For Ki\n    'Fighter': 'INT',\n    // Eldritch Knight\n    'Rogue': 'INT' // Arcane Trickster\n  };\n  return spellcastingAbilities[className] || 'INT';\n}\n\n/**\n * Cast a spell in combat\n */\nexport function castSpellInCombat({\n  spell,\n  caster,\n  targets = [],\n  slotLevel = null,\n  upcast = false\n}) {\n  const spellData = typeof spell === 'string' ? SPELL_DATABASE[spell] : spell;\n  if (!spellData) {\n    return {\n      success: false,\n      message: 'Spell not found',\n      results: []\n    };\n  }\n  const castLevel = slotLevel || spellData.level;\n  const results = [];\n\n  // Handle different spell types\n  switch (spellData.school) {\n    case 'Evocation':\n    case 'Conjuration':\n    case 'Necromancy':\n      // Damage spells\n      if (spellData.damage) {\n        results.push(...handleDamageSpell(spellData, caster, targets, castLevel, upcast));\n      }\n      break;\n    case 'Enchantment':\n    case 'Illusion':\n      // Control/debuff spells\n      results.push(...handleControlSpell(spellData, caster, targets));\n      break;\n    case 'Abjuration':\n      // Protective spells\n      results.push(...handleProtectionSpell(spellData, caster, targets));\n      break;\n    case 'Transmutation':\n      // Buff spells\n      results.push(...handleBuffSpell(spellData, caster, targets));\n      break;\n    default:\n      // Generic handling\n      if (spellData.damage) {\n        results.push(...handleDamageSpell(spellData, caster, targets, castLevel, upcast));\n      }\n  }\n  return {\n    success: true,\n    spell: spellData.name,\n    caster: caster.name,\n    results,\n    message: `${caster.name} casts ${spellData.name}!`\n  };\n}\n\n/**\n * Handle damage spell\n */\nfunction handleDamageSpell(spell, caster, targets, castLevel, upcast) {\n  const results = [];\n  const saveDC = calculateSpellSaveDC(caster);\n  targets.forEach(target => {\n    var _attackRoll, _saveRoll;\n    let damage = 0;\n    let damageRoll = null;\n    let attackRoll = null;\n    let saveRoll = null;\n    let isHit = false;\n\n    // Spell attack or saving throw?\n    if (spell.attack === 'ranged' || spell.attack === 'melee') {\n      // Spell attack\n      attackRoll = makeSpellAttack(caster, target.ac || target.armorClass);\n      isHit = attackRoll.isHit;\n      if (isHit) {\n        // Calculate damage (double on crit)\n        const baseDamage = spell.damage;\n\n        // Handle upcasting\n        let damageFormula = baseDamage;\n        if (upcast && spell.damagePerLevel && castLevel > spell.level) {\n          const extraLevels = castLevel - spell.level;\n          const extraDice = spell.damagePerLevel.match(/(\\d+)d(\\d+)/);\n          if (extraDice) {\n            const [, numDice, dieSize] = extraDice;\n            const totalExtraDice = parseInt(numDice) * extraLevels;\n            const baseMatch = baseDamage.match(/(\\d+)d(\\d+)([+-]\\d+)?/);\n            if (baseMatch) {\n              const [, baseNum, baseDie, modifier] = baseMatch;\n              const totalDice = parseInt(baseNum) + totalExtraDice;\n              damageFormula = `${totalDice}d${baseDie}${modifier || ''}`;\n            }\n          }\n        }\n        damageRoll = rollSpellDamage(damageFormula);\n        damage = attackRoll.isCritical ? damageRoll.total * 2 : damageRoll.total;\n      }\n    } else if (spell.save) {\n      // Saving throw\n      saveRoll = makeSpellSave(target, saveDC, spell.save);\n\n      // Calculate damage\n      let damageFormula = spell.damage;\n      if (upcast && spell.damagePerLevel && castLevel > spell.level) {\n        const extraLevels = castLevel - spell.level;\n        const extraDice = spell.damagePerLevel.match(/(\\d+)d(\\d+)/);\n        if (extraDice) {\n          const [, numDice, dieSize] = extraDice;\n          const totalExtraDice = parseInt(numDice) * extraLevels;\n          const baseMatch = spell.damage.match(/(\\d+)d(\\d+)([+-]\\d+)?/);\n          if (baseMatch) {\n            const [, baseNum, baseDie, modifier] = baseMatch;\n            const totalDice = parseInt(baseNum) + totalExtraDice;\n            damageFormula = `${totalDice}d${baseDie}${modifier || ''}`;\n          }\n        }\n      }\n      damageRoll = rollSpellDamage(damageFormula);\n\n      // Half damage on successful save for most damage spells\n      if (saveRoll.success) {\n        damage = Math.floor(damageRoll.total / 2);\n      } else {\n        damage = damageRoll.total;\n      }\n      isHit = true; // Always \"hits\" for save spells\n    }\n    results.push({\n      target: target.name,\n      attackRoll,\n      saveRoll,\n      damageRoll,\n      damage,\n      damageType: spell.damageType,\n      isHit,\n      isCritical: ((_attackRoll = attackRoll) === null || _attackRoll === void 0 ? void 0 : _attackRoll.isCritical) || false,\n      savedForHalf: ((_saveRoll = saveRoll) === null || _saveRoll === void 0 ? void 0 : _saveRoll.success) || false\n    });\n  });\n  return results;\n}\n\n/**\n * Handle control/debuff spell\n */\nfunction handleControlSpell(spell, caster, targets) {\n  const results = [];\n  const saveDC = calculateSpellSaveDC(caster);\n  targets.forEach(target => {\n    const saveRoll = makeSpellSave(target, saveDC, spell.save || 'WIS');\n\n    // Apply status effect if they fail\n    let statusEffect = null;\n    if (!saveRoll.success) {\n      // Map spell to status effect\n      const effectType = mapSpellToStatusEffect(spell.id);\n      if (effectType) {\n        var _spell$duration;\n        statusEffect = createStatusEffect({\n          type: effectType,\n          duration: ((_spell$duration = spell.duration) === null || _spell$duration === void 0 ? void 0 : _spell$duration.value) || 1,\n          durationType: spell.concentration ? DURATION_TYPES.CONCENTRATION : DURATION_TYPES.ROUNDS,\n          source: spell.name,\n          saveDC: saveDC,\n          saveAbility: spell.save || 'WIS',\n          spellName: spell.name\n        });\n      }\n    }\n    results.push({\n      target: target.name,\n      saveRoll,\n      statusEffect,\n      success: !saveRoll.success\n    });\n  });\n  return results;\n}\n\n/**\n * Handle protection spell\n */\nfunction handleProtectionSpell(spell, caster, targets) {\n  const results = [];\n  targets.forEach(target => {\n    let effect = null;\n\n    // Apply appropriate effect based on spell\n    if (spell.id === 'shield') {\n      effect = {\n        type: 'ac_bonus',\n        bonus: 5,\n        duration: 1\n      };\n    } else if (spell.id === 'mage_armor') {\n      var _target$abilities2;\n      effect = {\n        type: 'ac_set',\n        ac: 13 + Math.floor((((_target$abilities2 = target.abilities) === null || _target$abilities2 === void 0 ? void 0 : _target$abilities2.DEX) - 10) / 2),\n        duration: 8\n      };\n    }\n    results.push({\n      target: target.name,\n      effect,\n      success: true\n    });\n  });\n  return results;\n}\n\n/**\n * Handle buff spell\n */\nfunction handleBuffSpell(spell, caster, targets) {\n  const results = [];\n  targets.forEach(target => {\n    const effectType = mapSpellToStatusEffect(spell.id);\n    let statusEffect = null;\n    if (effectType) {\n      var _spell$duration2;\n      statusEffect = createStatusEffect({\n        type: effectType,\n        duration: ((_spell$duration2 = spell.duration) === null || _spell$duration2 === void 0 ? void 0 : _spell$duration2.value) || 1,\n        durationType: spell.concentration ? DURATION_TYPES.CONCENTRATION : DURATION_TYPES.ROUNDS,\n        source: spell.name,\n        spellName: spell.name\n      });\n    }\n    results.push({\n      target: target.name,\n      statusEffect,\n      success: true\n    });\n  });\n  return results;\n}\n\n/**\n * Map spell ID to status effect\n */\nfunction mapSpellToStatusEffect(spellId) {\n  const spellToEffect = {\n    'hold_person': STATUS_EFFECTS.PARALYZED,\n    'sleep': STATUS_EFFECTS.UNCONSCIOUS,\n    'blindness_deafness': STATUS_EFFECTS.BLINDED,\n    'charm_person': STATUS_EFFECTS.CHARMED,\n    'fear': STATUS_EFFECTS.FRIGHTENED,\n    'bless': STATUS_EFFECTS.BLESSED,\n    'bane': STATUS_EFFECTS.BANED,\n    'haste': STATUS_EFFECTS.HASTED,\n    'slow': STATUS_EFFECTS.SLOWED,\n    'web': STATUS_EFFECTS.RESTRAINED,\n    'grease': STATUS_EFFECTS.PRONE,\n    'faerie_fire': STATUS_EFFECTS.INVISIBLE,\n    // Actually makes them visible\n    'invisibility': STATUS_EFFECTS.INVISIBLE\n  };\n  return spellToEffect[spellId] || null;\n}\n\n/**\n * Apply spell results to combat\n */\nexport function applySpellResults(combat, results, updateCombatant) {\n  let updatedCombat = {\n    ...combat\n  };\n  results.forEach(result => {\n    if (result.damage > 0) {\n      // Find target in combat\n      const target = updatedCombat.combatants.find(c => c.name === result.target || c.id === result.target);\n      if (target) {\n        // Apply damage\n        const damagedTarget = applyDamage(target, result.damage, result.damageType);\n        updatedCombat = updateCombatant(updatedCombat, target.id || target.name, damagedTarget);\n      }\n    }\n    if (result.statusEffect) {\n      // Find target and apply status effect\n      const target = updatedCombat.combatants.find(c => c.name === result.target || c.id === result.target);\n      if (target) {\n        const affectedTarget = applyStatusEffect(target, result.statusEffect);\n        updatedCombat = updateCombatant(updatedCombat, target.id || target.name, affectedTarget);\n      }\n    }\n  });\n  return updatedCombat;\n}\n\n/**\n * Get spell damage preview (for UI)\n */\nexport function getSpellDamagePreview(spell, casterLevel, slotLevel = null) {\n  const spellData = typeof spell === 'string' ? SPELL_DATABASE[spell] : spell;\n  if (!spellData || !spellData.damage) return null;\n  const castLevel = slotLevel || spellData.level;\n  let damageFormula = spellData.damage;\n\n  // Handle upcasting\n  if (spellData.damagePerLevel && castLevel > spellData.level) {\n    const extraLevels = castLevel - spellData.level;\n    const extraDice = spellData.damagePerLevel.match(/(\\d+)d(\\d+)/);\n    if (extraDice) {\n      const [, numDice, dieSize] = extraDice;\n      const totalExtraDice = parseInt(numDice) * extraLevels;\n      const baseMatch = damageFormula.match(/(\\d+)d(\\d+)([+-]\\d+)?/);\n      if (baseMatch) {\n        const [, baseNum, baseDie, modifier] = baseMatch;\n        const totalDice = parseInt(baseNum) + totalExtraDice;\n        damageFormula = `${totalDice}d${baseDie}${modifier || ''}`;\n      }\n    }\n  }\n  return {\n    formula: damageFormula,\n    damageType: spellData.damageType,\n    attackType: spellData.attack || (spellData.save ? `${spellData.save} save` : 'other')\n  };\n}","map":{"version":3,"names":["SPELL_DATABASE","applyDamage","createStatusEffect","applyStatusEffect","STATUS_EFFECTS","DURATION_TYPES","rollSpellDamage","damageFormula","match","parseInt","numDice","dieSize","modifier","total","rolls","i","roll","Math","floor","random","push","formula","makeSpellAttack","caster","targetAC","spellAttackBonus","d20","attackBonus","spellcastingAbility","getSpellcastingAbility","class","abilityModifier","abilities","proficiencyBonus","level","totalRoll","isCritical","isFumble","isHit","makeSpellSave","target","saveDC","saveAbility","_target$abilities","_target$proficiencies","_target$proficiencies2","abilityScore","isProficient","proficiencies","savingThrows","includes","saveModifier","success","criticalFail","calculateSpellSaveDC","className","spellcastingAbilities","castSpellInCombat","spell","targets","slotLevel","upcast","spellData","message","results","castLevel","school","damage","handleDamageSpell","handleControlSpell","handleProtectionSpell","handleBuffSpell","name","forEach","_attackRoll","_saveRoll","damageRoll","attackRoll","saveRoll","attack","ac","armorClass","baseDamage","damagePerLevel","extraLevels","extraDice","totalExtraDice","baseMatch","baseNum","baseDie","totalDice","save","damageType","savedForHalf","statusEffect","effectType","mapSpellToStatusEffect","id","_spell$duration","type","duration","value","durationType","concentration","CONCENTRATION","ROUNDS","source","spellName","effect","bonus","_target$abilities2","DEX","_spell$duration2","spellId","spellToEffect","PARALYZED","UNCONSCIOUS","BLINDED","CHARMED","FRIGHTENED","BLESSED","BANED","HASTED","SLOWED","RESTRAINED","PRONE","INVISIBLE","applySpellResults","combat","updateCombatant","updatedCombat","result","combatants","find","c","damagedTarget","affectedTarget","getSpellDamagePreview","casterLevel","attackType"],"sources":["C:/Users/Hakty/Desktop/AI-Dungeon-Master/frontend/src/utils/spellCombatSystem.js"],"sourcesContent":["// frontend/src/utils/spellCombatSystem.js\n\n/**\n * Spell Combat System\n * Handles spell casting, damage, saving throws, and spell attacks in combat\n */\n\nimport { SPELL_DATABASE } from './spellSystem';\nimport { applyDamage } from './combatSystem';\nimport { \n  createStatusEffect, \n  applyStatusEffect,\n  STATUS_EFFECTS,\n  DURATION_TYPES \n} from './statusEffectSystem';\n\n/**\n * Roll dice for spell damage\n */\nexport function rollSpellDamage(damageFormula) {\n  if (!damageFormula) return 0;\n  \n  // Handle formulas like \"3d6\", \"4d8+4\", \"8d6\"\n  const match = damageFormula.match(/(\\d+)d(\\d+)([+-]\\d+)?/);\n  if (!match) {\n    // Flat damage like \"10\"\n    return parseInt(damageFormula) || 0;\n  }\n  \n  const [, numDice, dieSize, modifier] = match;\n  let total = 0;\n  const rolls = [];\n  \n  for (let i = 0; i < parseInt(numDice); i++) {\n    const roll = Math.floor(Math.random() * parseInt(dieSize)) + 1;\n    rolls.push(roll);\n    total += roll;\n  }\n  \n  if (modifier) {\n    total += parseInt(modifier);\n  }\n  \n  return {\n    total,\n    rolls,\n    formula: damageFormula,\n    modifier: modifier || '+0'\n  };\n}\n\n/**\n * Make a spell attack roll\n */\nexport function makeSpellAttack(caster, targetAC, spellAttackBonus = null) {\n  const d20 = Math.floor(Math.random() * 20) + 1;\n  \n  // Calculate spell attack bonus if not provided\n  let attackBonus = spellAttackBonus;\n  if (attackBonus === null) {\n    const spellcastingAbility = getSpellcastingAbility(caster.class);\n    const abilityModifier = Math.floor((caster.abilities[spellcastingAbility] - 10) / 2);\n    const proficiencyBonus = Math.floor((caster.level - 1) / 4) + 2;\n    attackBonus = abilityModifier + proficiencyBonus;\n  }\n  \n  const totalRoll = d20 + attackBonus;\n  \n  const isCritical = d20 === 20;\n  const isFumble = d20 === 1;\n  const isHit = isCritical || (!isFumble && totalRoll >= targetAC);\n  \n  return {\n    d20,\n    attackBonus,\n    totalRoll,\n    isHit,\n    isCritical,\n    isFumble,\n    targetAC\n  };\n}\n\n/**\n * Make a saving throw for spell\n */\nexport function makeSpellSave(target, saveDC, saveAbility) {\n  const d20 = Math.floor(Math.random() * 20) + 1;\n  \n  // Get ability modifier\n  const abilityScore = target.abilities?.[saveAbility] || 10;\n  const abilityModifier = Math.floor((abilityScore - 10) / 2);\n  \n  // Check proficiency\n  const isProficient = target.proficiencies?.savingThrows?.includes(saveAbility) || false;\n  const proficiencyBonus = target.level ? Math.floor((target.level - 1) / 4) + 2 : 0;\n  \n  const saveModifier = abilityModifier + (isProficient ? proficiencyBonus : 0);\n  const totalRoll = d20 + saveModifier;\n  \n  const success = d20 === 20 || totalRoll >= saveDC;\n  const criticalFail = d20 === 1;\n  \n  return {\n    d20,\n    saveModifier,\n    totalRoll,\n    saveDC,\n    saveAbility,\n    success,\n    criticalFail\n  };\n}\n\n/**\n * Calculate spell save DC\n */\nexport function calculateSpellSaveDC(caster) {\n  const spellcastingAbility = getSpellcastingAbility(caster.class);\n  const abilityModifier = Math.floor((caster.abilities[spellcastingAbility] - 10) / 2);\n  const proficiencyBonus = Math.floor((caster.level - 1) / 4) + 2;\n  \n  return 8 + proficiencyBonus + abilityModifier;\n}\n\n/**\n * Get spellcasting ability for class\n */\nexport function getSpellcastingAbility(className) {\n  const spellcastingAbilities = {\n    'Wizard': 'INT',\n    'Sorcerer': 'CHA',\n    'Warlock': 'CHA',\n    'Bard': 'CHA',\n    'Cleric': 'WIS',\n    'Druid': 'WIS',\n    'Paladin': 'CHA',\n    'Ranger': 'WIS',\n    'Monk': 'WIS', // For Ki\n    'Fighter': 'INT', // Eldritch Knight\n    'Rogue': 'INT'    // Arcane Trickster\n  };\n  \n  return spellcastingAbilities[className] || 'INT';\n}\n\n/**\n * Cast a spell in combat\n */\nexport function castSpellInCombat({\n  spell,\n  caster,\n  targets = [],\n  slotLevel = null,\n  upcast = false\n}) {\n  const spellData = typeof spell === 'string' ? SPELL_DATABASE[spell] : spell;\n  \n  if (!spellData) {\n    return {\n      success: false,\n      message: 'Spell not found',\n      results: []\n    };\n  }\n  \n  const castLevel = slotLevel || spellData.level;\n  const results = [];\n  \n  // Handle different spell types\n  switch (spellData.school) {\n    case 'Evocation':\n    case 'Conjuration':\n    case 'Necromancy':\n      // Damage spells\n      if (spellData.damage) {\n        results.push(...handleDamageSpell(spellData, caster, targets, castLevel, upcast));\n      }\n      break;\n      \n    case 'Enchantment':\n    case 'Illusion':\n      // Control/debuff spells\n      results.push(...handleControlSpell(spellData, caster, targets));\n      break;\n      \n    case 'Abjuration':\n      // Protective spells\n      results.push(...handleProtectionSpell(spellData, caster, targets));\n      break;\n      \n    case 'Transmutation':\n      // Buff spells\n      results.push(...handleBuffSpell(spellData, caster, targets));\n      break;\n      \n    default:\n      // Generic handling\n      if (spellData.damage) {\n        results.push(...handleDamageSpell(spellData, caster, targets, castLevel, upcast));\n      }\n  }\n  \n  return {\n    success: true,\n    spell: spellData.name,\n    caster: caster.name,\n    results,\n    message: `${caster.name} casts ${spellData.name}!`\n  };\n}\n\n/**\n * Handle damage spell\n */\nfunction handleDamageSpell(spell, caster, targets, castLevel, upcast) {\n  const results = [];\n  const saveDC = calculateSpellSaveDC(caster);\n  \n  targets.forEach(target => {\n    let damage = 0;\n    let damageRoll = null;\n    let attackRoll = null;\n    let saveRoll = null;\n    let isHit = false;\n    \n    // Spell attack or saving throw?\n    if (spell.attack === 'ranged' || spell.attack === 'melee') {\n      // Spell attack\n      attackRoll = makeSpellAttack(caster, target.ac || target.armorClass);\n      isHit = attackRoll.isHit;\n      \n      if (isHit) {\n        // Calculate damage (double on crit)\n        const baseDamage = spell.damage;\n        \n        // Handle upcasting\n        let damageFormula = baseDamage;\n        if (upcast && spell.damagePerLevel && castLevel > spell.level) {\n          const extraLevels = castLevel - spell.level;\n          const extraDice = spell.damagePerLevel.match(/(\\d+)d(\\d+)/);\n          if (extraDice) {\n            const [, numDice, dieSize] = extraDice;\n            const totalExtraDice = parseInt(numDice) * extraLevels;\n            const baseMatch = baseDamage.match(/(\\d+)d(\\d+)([+-]\\d+)?/);\n            if (baseMatch) {\n              const [, baseNum, baseDie, modifier] = baseMatch;\n              const totalDice = parseInt(baseNum) + totalExtraDice;\n              damageFormula = `${totalDice}d${baseDie}${modifier || ''}`;\n            }\n          }\n        }\n        \n        damageRoll = rollSpellDamage(damageFormula);\n        damage = attackRoll.isCritical ? damageRoll.total * 2 : damageRoll.total;\n      }\n    } else if (spell.save) {\n      // Saving throw\n      saveRoll = makeSpellSave(target, saveDC, spell.save);\n      \n      // Calculate damage\n      let damageFormula = spell.damage;\n      if (upcast && spell.damagePerLevel && castLevel > spell.level) {\n        const extraLevels = castLevel - spell.level;\n        const extraDice = spell.damagePerLevel.match(/(\\d+)d(\\d+)/);\n        if (extraDice) {\n          const [, numDice, dieSize] = extraDice;\n          const totalExtraDice = parseInt(numDice) * extraLevels;\n          const baseMatch = spell.damage.match(/(\\d+)d(\\d+)([+-]\\d+)?/);\n          if (baseMatch) {\n            const [, baseNum, baseDie, modifier] = baseMatch;\n            const totalDice = parseInt(baseNum) + totalExtraDice;\n            damageFormula = `${totalDice}d${baseDie}${modifier || ''}`;\n          }\n        }\n      }\n      \n      damageRoll = rollSpellDamage(damageFormula);\n      \n      // Half damage on successful save for most damage spells\n      if (saveRoll.success) {\n        damage = Math.floor(damageRoll.total / 2);\n      } else {\n        damage = damageRoll.total;\n      }\n      \n      isHit = true; // Always \"hits\" for save spells\n    }\n    \n    results.push({\n      target: target.name,\n      attackRoll,\n      saveRoll,\n      damageRoll,\n      damage,\n      damageType: spell.damageType,\n      isHit,\n      isCritical: attackRoll?.isCritical || false,\n      savedForHalf: saveRoll?.success || false\n    });\n  });\n  \n  return results;\n}\n\n/**\n * Handle control/debuff spell\n */\nfunction handleControlSpell(spell, caster, targets) {\n  const results = [];\n  const saveDC = calculateSpellSaveDC(caster);\n  \n  targets.forEach(target => {\n    const saveRoll = makeSpellSave(target, saveDC, spell.save || 'WIS');\n    \n    // Apply status effect if they fail\n    let statusEffect = null;\n    if (!saveRoll.success) {\n      // Map spell to status effect\n      const effectType = mapSpellToStatusEffect(spell.id);\n      if (effectType) {\n        statusEffect = createStatusEffect({\n          type: effectType,\n          duration: spell.duration?.value || 1,\n          durationType: spell.concentration ? DURATION_TYPES.CONCENTRATION : DURATION_TYPES.ROUNDS,\n          source: spell.name,\n          saveDC: saveDC,\n          saveAbility: spell.save || 'WIS',\n          spellName: spell.name\n        });\n      }\n    }\n    \n    results.push({\n      target: target.name,\n      saveRoll,\n      statusEffect,\n      success: !saveRoll.success\n    });\n  });\n  \n  return results;\n}\n\n/**\n * Handle protection spell\n */\nfunction handleProtectionSpell(spell, caster, targets) {\n  const results = [];\n  \n  targets.forEach(target => {\n    let effect = null;\n    \n    // Apply appropriate effect based on spell\n    if (spell.id === 'shield') {\n      effect = {\n        type: 'ac_bonus',\n        bonus: 5,\n        duration: 1\n      };\n    } else if (spell.id === 'mage_armor') {\n      effect = {\n        type: 'ac_set',\n        ac: 13 + Math.floor((target.abilities?.DEX - 10) / 2),\n        duration: 8\n      };\n    }\n    \n    results.push({\n      target: target.name,\n      effect,\n      success: true\n    });\n  });\n  \n  return results;\n}\n\n/**\n * Handle buff spell\n */\nfunction handleBuffSpell(spell, caster, targets) {\n  const results = [];\n  \n  targets.forEach(target => {\n    const effectType = mapSpellToStatusEffect(spell.id);\n    let statusEffect = null;\n    \n    if (effectType) {\n      statusEffect = createStatusEffect({\n        type: effectType,\n        duration: spell.duration?.value || 1,\n        durationType: spell.concentration ? DURATION_TYPES.CONCENTRATION : DURATION_TYPES.ROUNDS,\n        source: spell.name,\n        spellName: spell.name\n      });\n    }\n    \n    results.push({\n      target: target.name,\n      statusEffect,\n      success: true\n    });\n  });\n  \n  return results;\n}\n\n/**\n * Map spell ID to status effect\n */\nfunction mapSpellToStatusEffect(spellId) {\n  const spellToEffect = {\n    'hold_person': STATUS_EFFECTS.PARALYZED,\n    'sleep': STATUS_EFFECTS.UNCONSCIOUS,\n    'blindness_deafness': STATUS_EFFECTS.BLINDED,\n    'charm_person': STATUS_EFFECTS.CHARMED,\n    'fear': STATUS_EFFECTS.FRIGHTENED,\n    'bless': STATUS_EFFECTS.BLESSED,\n    'bane': STATUS_EFFECTS.BANED,\n    'haste': STATUS_EFFECTS.HASTED,\n    'slow': STATUS_EFFECTS.SLOWED,\n    'web': STATUS_EFFECTS.RESTRAINED,\n    'grease': STATUS_EFFECTS.PRONE,\n    'faerie_fire': STATUS_EFFECTS.INVISIBLE, // Actually makes them visible\n    'invisibility': STATUS_EFFECTS.INVISIBLE\n  };\n  \n  return spellToEffect[spellId] || null;\n}\n\n/**\n * Apply spell results to combat\n */\nexport function applySpellResults(combat, results, updateCombatant) {\n  let updatedCombat = { ...combat };\n  \n  results.forEach(result => {\n    if (result.damage > 0) {\n      // Find target in combat\n      const target = updatedCombat.combatants.find(\n        c => c.name === result.target || c.id === result.target\n      );\n      \n      if (target) {\n        // Apply damage\n        const damagedTarget = applyDamage(target, result.damage, result.damageType);\n        updatedCombat = updateCombatant(updatedCombat, target.id || target.name, damagedTarget);\n      }\n    }\n    \n    if (result.statusEffect) {\n      // Find target and apply status effect\n      const target = updatedCombat.combatants.find(\n        c => c.name === result.target || c.id === result.target\n      );\n      \n      if (target) {\n        const affectedTarget = applyStatusEffect(target, result.statusEffect);\n        updatedCombat = updateCombatant(updatedCombat, target.id || target.name, affectedTarget);\n      }\n    }\n  });\n  \n  return updatedCombat;\n}\n\n/**\n * Get spell damage preview (for UI)\n */\nexport function getSpellDamagePreview(spell, casterLevel, slotLevel = null) {\n  const spellData = typeof spell === 'string' ? SPELL_DATABASE[spell] : spell;\n  if (!spellData || !spellData.damage) return null;\n  \n  const castLevel = slotLevel || spellData.level;\n  let damageFormula = spellData.damage;\n  \n  // Handle upcasting\n  if (spellData.damagePerLevel && castLevel > spellData.level) {\n    const extraLevels = castLevel - spellData.level;\n    const extraDice = spellData.damagePerLevel.match(/(\\d+)d(\\d+)/);\n    if (extraDice) {\n      const [, numDice, dieSize] = extraDice;\n      const totalExtraDice = parseInt(numDice) * extraLevels;\n      const baseMatch = damageFormula.match(/(\\d+)d(\\d+)([+-]\\d+)?/);\n      if (baseMatch) {\n        const [, baseNum, baseDie, modifier] = baseMatch;\n        const totalDice = parseInt(baseNum) + totalExtraDice;\n        damageFormula = `${totalDice}d${baseDie}${modifier || ''}`;\n      }\n    }\n  }\n  \n  return {\n    formula: damageFormula,\n    damageType: spellData.damageType,\n    attackType: spellData.attack || (spellData.save ? `${spellData.save} save` : 'other')\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}